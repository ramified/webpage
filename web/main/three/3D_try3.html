
<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
	<title>Three.js - Fundamentals</title>
</head>
<body>
	<div class="center"><canvas id="c"></canvas></div>
</body>
<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<!-- <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script> -->
<style>
html, body {
	margin: 0;
	height: 100%;
}
#c {
	width: 100%;
	height: 100%;
	display: block;
}
</style>
<style>

canvas {
	padding: 0;
	margin: auto;
	display: block;
	width: 400px;
}
</style>
<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.148.0/build/three.module.js",
			"three/addons/": "https://unpkg.com/three@0.147.0/examples/jsm/"
		}
	}
</script>

<script type="module">
	import * as THREE from 'three';
	import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
	import {GUI} from 'three/addons/libs/lil-gui.module.min.js';
    // import { MeshLine, MeshLineMaterial, MeshLineRaycast } from 'threemeshline';

    function main() {
    	const canvas = document.querySelector('#c');
    	const renderer = new THREE.WebGLRenderer({
    		canvas,
    		alpha: true,
    	});

    	const fov = 40;
        const aspect = 1;  // the canvas default
        const near = 0.3;
        const far = 10;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(0, 1.4, 5);




        const scene = new THREE.Scene();
        // scene.background = new THREE.Color('blue');
        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 0, 0);
        controls.enableDamping = true;
        controls.update();

        const material = new THREE.MeshPhongMaterial({
        	color: 'blue',  
        	shininess: 20,
        	opacity: 0.8,
        	transparent: true,
        	flatShading: true,
        });
// material.wireframe = true;

// Cube
const boxWidth = 1;
const boxHeight = 1;
const boxDepth = 1;
const radius = 0.5;


const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
const geometry2 = new THREE.SphereGeometry( radius, 32, 16 );
const geometry3 = new THREE.OctahedronGeometry(radius);
const position = geometry2.getAttribute('position');
//     console.log( position.count ); // 24
//     console.log( position.array.length ); // 72
//     console.log( position.count * 3 === position.array.length); // true
// alert(" odd " +  typeof position + position.array[0] + " " + position.array[1] + " "+position.array[2] );


  // const cube = new THREE.Mesh(geometry, material);
  // scene.add(cube);


// Light
function addLight(...pos) {
	const color = 0xFFFFFF;
	const intensity = 2;
	const light = new THREE.DirectionalLight(color, intensity);
	light.position.set(...pos);
	scene.add(light);
}
addLight(2,2,2);


const skyColor = 0xB1E1FF;  // light blue
const groundColor = 0xB97A20;  // brownish orange
const intensity = 1;
const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
scene.add(light);


// group
function makeInstance(geometry, material, x) {

	const cube = new THREE.Mesh(geometry, material);
	scene.add(cube);

	cube.position.x = x;

	return cube;
}

const cubes = [
makeInstance(geometry2, material,  0),
// makeInstance(geometry2, material, -2),
// makeInstance(geometry3, material,  2),
];


class ColorGUIHelper {
 constructor(object, prop) {
     this.object = object;
     this.prop = prop;
 }
 get value() {
     return `#${this.object[this.prop].getHexString()}`;
 }
 set value(hexString) {
     this.object[this.prop].set(hexString);
 }
}



const gui = new GUI();
gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('skyColor');
gui.addColor(new ColorGUIHelper(light, 'groundColor'), 'value').name('groundColor');
gui.add(light, 'intensity', 0, 2, 0.01);

function resizeRendererToDisplaySize(renderer) {
	const canvas = renderer.domElement;
	const width = canvas.clientWidth;
	const height = canvas.clientHeight;
	const needResize = canvas.width !== width || canvas.height !== height;
	if (needResize) {
		renderer.setSize(width, height, false);
	}
	return needResize;
}


// Real axesHelper
// const axesHelper = new THREE.AxesHelper( 2 );
// scene.add( axesHelper );


function createLine(from, to, width, color, arrowWidth, arrowLength) {
	const m = new THREE.MeshStandardMaterial({
		color: color,
	});
	const dist = from.distanceTo(to);
	if (dist < 0.0001) return;

	let geometry = new THREE.CylinderGeometry(width, width, dist, 10, 1);
	let mesh = new THREE.Mesh(geometry, m);
	const axis = new THREE.Vector3(0, 1, 0);
	geometry.dispose();
	const vector = (new THREE.Vector3()).subVectors(to, from);
	if (arrowWidth != undefined) {
		const geometry2 = new THREE.CylinderGeometry(0, arrowWidth, arrowLength, 10, 1);
        // geometry2.translate(0, (dist - arrowLength) / 2, 0);
        geometry2.translate(0, (dist + arrowLength) / 2, 0);
        geometry.merge(geometry2);      //How to merge??
        // alert("Hello! Here it is actually wrong!!");
        let mesh2 = new THREE.Mesh(geometry2, m);
        mesh2.quaternion.setFromUnitVectors(axis, vector.clone().normalize());
        mesh2.position.copy(from.clone().addScaledVector(vector, 0.5));
        sceneAdd(scene, mesh2, "vertices");
    }

    


    mesh.quaternion.setFromUnitVectors(axis, vector.clone().normalize());
    mesh.position.copy(from.clone().addScaledVector(vector, 0.5));

    return mesh;
}

function getVertices() {
	const v = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0),
	new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)];
	return v;
};
const v = getVertices();
const w = 0.02;
const arrowWidth = 0.05;
const arrowLength = 0.1;
const c = 0x0000ff;

function sceneAdd(scene, object, group) {
	if (scene.groupings == undefined) {
		scene.groupings = new Map();
	}
	if (scene.groupings.get(group) == undefined) {
		scene.groupings.set(group, []);
	}
	scene.groupings.get(group).push(object);
	scene.add(object);
}

// sceneAdd(scene, createLine(v[0], v[1], w, 0xff0000, arrowWidth, arrowLength), "vertices");
// sceneAdd(scene, createLine(v[0], v[3], w, 0xff0000, arrowWidth, arrowLength), "vertices");
// sceneAdd(scene, createLine(v[0], v[5], w, 0xff0000, arrowWidth, arrowLength), "vertices");

function render(time) {
    // time *= 0.001;  // convert time to seconds

    if (resizeRendererToDisplaySize(renderer)) {
    	const canvas = renderer.domElement;
    	camera.aspect = canvas.clientWidth / canvas.clientHeight;
    	camera.updateProjectionMatrix();
    }

    // cubes.forEach((cube, ndx) => {
    //  const speed = 0.1 + ndx * .3;
    //  const rot = time * speed;
    //  cube.rotation.x = rot;
    //  cube.rotation.y = rot;
    // });

    renderer.render(scene, camera);
    requestAnimationFrame(render);
}
requestAnimationFrame(render);
}
// renderer.render(scene, camera);

main();

</script>
</html>

